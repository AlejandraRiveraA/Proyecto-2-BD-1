/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/*
Importacion de paquetes utilizados en el controlador.

*/

package project2;
import Connection.Connect;
import java.sql.CallableStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import static javax.swing.JOptionPane.showMessageDialog;

/**
 *
 * @author andre
 */

//COnstructor del controlador, utiliza un singleton para la primera vez que se llame se genere la instancia
public class Controller {
    private static Controller Controller;
    public  static Controller getInstance(){
        if(Controller==null){
            Controller= new Controller();
        }
        return Controller;
    }
    // PROCEDIMIENTOS PARA USUUARIO
    //Atributo que almacena el nickname del usuario  actual
    private String user;
    //Variables con sus sets y gets para ventana de estadisticas
    private String typeEventStatistic;
    private String dateEventStatisitc;
    public void settypeEventStatistic(String newEvent){
        typeEventStatistic = newEvent;
    }

    public void setdateEventStatisitc(String newDate){
        dateEventStatisitc = newDate;
    }

    public String gettypeEventStatistic(){
        return typeEventStatistic;
    }

    public String getdateEventStatistic(){
        return dateEventStatisitc;
    }

    
    public void setUser(String newUser){
        user = newUser;
    }   
    
    public String getUser(){
        return user;
    }
    
    //Procedimiento para cambiar la contrasena de un usuario
    public void changePassword(String user, String oldPassword, String newPassword){
       updateUser(user, null, newPassword, null);  
    }
    //Procedimiento que returna true si la contrasena del nickname ingresado coincide con la contrasena
       public  boolean validatePasssword(String nickname,String password){ 
           try{
              password = Encrypter.encryptPassword(password);
            CallableStatement stmt= Connect.getInstance().getStmt("{call getUserPassword(?)}");
            stmt.setString(1, nickname);
            ResultSet myRs = stmt.executeQuery();
            String ResultPassword = null;
            while (myRs.next()) {
                ResultPassword = myRs.getString("password");
            }
         if( password.equals(ResultPassword)){
             return true;                     
         }else{
             showMessageDialog(null,"La contraseña es incorrecta.");
             return false;
         }
      }catch(SQLException ex){
      
      }     
           
           return false;
       }
       
    //Procedimiento que cre un nuevo usuario   
    public  void createUser(String nickname, String password){
         try{
       CallableStatement stmt= Connect.getInstance().getStmt("{call insert_user(?,?,?)}");
        password = Encrypter.encryptPassword(password);
         stmt.setString(1,nickname);
         stmt.setString(2, password);
         stmt.setInt(3, 2);
         
          stmt.execute();
          showMessageDialog(null,"El usuario ha sido creado con éxito.");
      }catch(SQLException ex){
      showMessageDialog(null,"Este usuario ya existe");
      }
    
    }
    
    
    //Procedimiento para actualizar la información de un usuario, si recibe nulls 
    public  void updateUser(String nickname,String newNickname,String newpassword,String newUserType){
         try{
       CallableStatement stmt= Connect.getInstance().getStmt("{call updateUser(?,?,?,?)}");
       if(newpassword!=null){
        newpassword = Encrypter.encryptPassword(newpassword);
       }
         stmt.setString(1,nickname);
         stmt.setString(2, newNickname);
         stmt.setString(3, newpassword);
         stmt.setString(4, newUserType);
         stmt.execute();
         showMessageDialog(null,"La contraseña ha cambiado con éxito.");
      }catch(SQLException ex){
         showMessageDialog(null,"Laa contraseñas no coinicden.");
      }
    
    }
    //Booleano que regresa true un usuario es admin
    public   boolean  isAdmin(){
         try{          
            CallableStatement stmt= Connect.getInstance().getStmt("{call isAdmin(?)}");
            stmt.setString(1, user);
            ResultSet myRs = stmt.executeQuery();
            String result = "";
            while (myRs.next()) {
                result = myRs.getString("result");
            }
         if( result.equals("true")){

             return true;           
         }else{
             return false;
         }
      }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
           
           return false;
    
    }
    
    //FIN PROCEDIMIENTOS PARA USUARIO
    
    //INICIO  ALIGNMENT 
    //Procedimiento para crear alineaciones. recibe el nombre
    public  int createAlignment(String name ){
       try{
       CallableStatement stmt= Connect.getInstance().getStmt("{call insert_alignment(?)}");
         stmt.setString(1, name);
         stmt.execute();
      }catch(SQLException ex){
      showMessageDialog(null,"La alineación ya se encuentra registrada");
      }     
        
        return 0;
        
    }
    //terminar
    //Procedimiento que actualiza una alineacione, recibe la alineacion a cambiar y el nuevo nombre
    public  void updateAlignment(String aligmentName,String newName){
       try{
            CallableStatement stmt= Connect.getInstance().getStmt("{call updateAlignment(?,?)}");
            stmt.setInt(1, getIdAlignment(aligmentName));
            stmt.setString(2, newName);
            stmt.execute();
        }catch(SQLException ex){
            
      showMessageDialog(null,"La alineación ya se encuentra registrada");
      }                              
    }
    //Procedimiento que regresa el id de la alineacion a partir del nombre
    public  int getIdAlignment(String aligmentName){
        int idAlignment= -1;
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getIdAlignment(?)}");
        stmt.setString(1, aligmentName);
        ResultSet myRs = stmt.executeQuery();     
        while(myRs.next()){
        idAlignment= myRs.getInt("id_alignment");
        }
      }catch(SQLException ex){
        System.out.println(ex.getMessage());
      }                              
       return idAlignment;
    }
    
    //Procedimiento que regresa la lista de todas las alineaciones existentes
    public  ArrayList<String> getAlignmentNames(){
        ArrayList<String> alignments =new ArrayList<String>();
        try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getAlignmentNames()}");
        ResultSet myRs = stmt.executeQuery();
        while(myRs.next()){
            alignments.add(myRs.getString("alignment_name"));
        }
       }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
        return alignments;
    }
    //FIN ALIGNMENT
  
    
    //INICIO NACIONALIDAD
    //Procedimiento que inserta una nueva nacionalidad
        public  void insertNationality(String nacionalityName){
       try{
       CallableStatement stmt= Connect.getInstance().getStmt("{call insert_nationality(?)}");
         stmt.setString(1, nacionalityName);
         stmt.execute();
      }catch(SQLException ex){
                 showMessageDialog(null,"La nacionalidad ingresada ya se encuentra insertada.");

      }     
     }
        
      //Procedimiento que actualiza la nacionalidad a apartir de que se le envie el nombre de la nacionalidad a cambiar y el nuevo nombre
      public  void updateNationality(String NationalitytName,String newName){
       try{
            CallableStatement stmt= Connect.getInstance().getStmt("{call updateNationality(?,?)}");
            stmt.setInt(1, getIdNationality(NationalitytName));
            stmt.setString(2, newName);
            stmt.execute();
        }catch(SQLException ex){
            showMessageDialog(null,"La nacionalidad ingresada ya se encuentra insertada.");
      }                              
    }   
      //Procedimiento que devuelve el id de la nacionalidad a partir del nombre
     public  int getIdNationality(String NationalityName){
        int idAlignment= -1;
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getIdNacionality(?)}");
        stmt.setString(1, NationalityName);
        ResultSet myRs = stmt.executeQuery();     
        while(myRs.next()){
        idAlignment= myRs.getInt("id_Nationality");
        }
      }catch(SQLException ex){
        System.out.println(ex.getMessage());
      }                              
       return idAlignment;
    }
     
     //Procedimiento que devuelve una lista con todas la nacionalidades
     public  ArrayList<String> getNationalityNames(){
       ArrayList<String>Nationality= new ArrayList<String>();
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getNationalityNames()}");
        ResultSet myRs = stmt.executeQuery();
        while(myRs.next()){
            Nationality.add(myRs.getString("Nationality_name"));
        }
       }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
        return Nationality;
    }
     
      
    //FIN NACIONALIDAD
    
    //      GETS DE  NOMBRES DE LOCALIZACIONES
     //Procedimiento que devuelve una lista con todos los nombres de los continentes
    public  ArrayList<String> getContinentsName(){
       ArrayList<String>Continents= new ArrayList<String>();
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getContinentsName()}");
        ResultSet myRs = stmt.executeQuery();
        while(myRs.next()){
            Continents.add(myRs.getString("continent_name"));
        }
       }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
        return Continents;
    }
  
    //Procedimiento que devuelve todos los nombres de los paises a partir de un continente
    public  ArrayList<String> getCountryNames(String continentName){
       ArrayList<String>countries= new ArrayList<String>();
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getCountryNames(?)}");
        stmt.setString(1, continentName);
        ResultSet myRs = stmt.executeQuery();
        while(myRs.next()){
            countries.add(myRs.getString("country_name"));
        }
       }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
        return countries;
    }
        
   //Procedimiento que devuelve una lista con todas las provincias a partir del pais 
    
   public  ArrayList<String> getProvinceNames(String CountryName){
       ArrayList<String>provinces= new ArrayList<String>();
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getProvinceNames(?)}");
        stmt.setString(1, CountryName);
        ResultSet myRs = stmt.executeQuery();
        while(myRs.next()){
            provinces.add(myRs.getString("province_name"));
        }
       }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
        return provinces;
   
   }
   
   //Procedimiento que devuelve los nombres de los cantones a parit de la provincia
   public  ArrayList<String> getCantonNames(String ProvinceName){
        ArrayList<String>Cantons= new ArrayList<String>();
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getCantonNames(?)}");
        stmt.setString(1, ProvinceName);
        ResultSet myRs = stmt.executeQuery();
        while(myRs.next()){
            Cantons.add(myRs.getString("canton_name"));
       }
       }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
        return Cantons;
   
   }
   
   //Procedimiento que devuelve los distritos a partir de un canton
   public  ArrayList<String> getDistrictNames(String ProvinceName){
       ArrayList<String>Districts= new ArrayList<String>();
       try{
       CallableStatement stmt= Connect.getInstance().getStmt("{call getDistrictNames(?)}");
       stmt.setString(1, ProvinceName);
       ResultSet myRs = stmt.executeQuery();
       while(myRs.next()){
           Districts.add(myRs.getString("district_name"));
       }
       }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
        return Districts;
   }
   
   //Procedimiento que devuelve una lista con todos los estadios
   public ArrayList<String> getAllStadium(){
       
       ArrayList<String>stadium= new ArrayList<String>();
       try{
       CallableStatement stmt= Connect.getInstance().getStmt("{call getAllStadium()}");
       
       ResultSet myRs = stmt.executeQuery();
       while(myRs.next()){
           stadium.add(myRs.getString("stadium_name"));
       }
       }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
        return stadium;
   }
   
   //Procedimiento que devuelve una lista con todos los nombres de estadios
   public ArrayList<String> getStadiumNames(String ProvinceName){
       ArrayList<String> Stadium = new ArrayList<String>();
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getStadiumNames(?)}");
        stmt.setInt(1,getIdProvince(ProvinceName));
        ResultSet myRs = stmt.executeQuery();
        while(myRs.next()){
            Stadium.add(myRs.getString("stadium_name"));
        }
       }catch(SQLException ex){
      System.out.println(ex.getMessage());
      }     
        return Stadium;
   }
    // FINAL GETS NOMBRES LOCALIZACIONES
    
   //INICIO GETS ID LOCALIZACIONES
   //Get del id de un contienente a partir del nombre
   public  int getIdContinent(String NameContinent){
    int idContinent=-1;
    try{
      CallableStatement stmt= Connect.getInstance().getStmt("{call getIdContinent(?)}");
      stmt.setString(1,NameContinent);
      ResultSet myRs = stmt.executeQuery();
      while(myRs.next()){
            idContinent= myRs.getInt("id_continent");
        }
    }catch(SQLException ex){
        System.out.println(ex.getMessage());
    }
        return idContinent;
   }
   
   
    //Get del id de un pais a partir del nombre
   public  int getIdCountry(String NameCountry){
    int idCountry=-1;
    try{
      CallableStatement stmt= Connect.getInstance().getStmt("{call getIdCountry(?)}");
      stmt.setString(1,NameCountry);
      ResultSet myRs = stmt.executeQuery();
      while(myRs.next()){
            idCountry= myRs.getInt("id_country");
        }
    }catch(SQLException ex){
        System.out.println(ex.getMessage());
    }
        return idCountry;
   }
   
    //Get del id de un provincia a partir del nombre
    public  int getIdProvince(String NameProvince){
    int idProvince=-1;
    try{
      CallableStatement stmt= Connect.getInstance().getStmt("{call getIdProvince(?)}");
      stmt.setString(1,NameProvince);
      ResultSet myRs = stmt.executeQuery();
      while(myRs.next()){
            idProvince= myRs.getInt("id_province");
        }
    }catch(SQLException ex){
        System.out.println(ex.getMessage());
    }
        return idProvince;
   }
    
     //Get del id de un canton a partir del nombre
    public  int getIdCanton(String NameCanton){
    int idCanton=-1;
    try{
      CallableStatement stmt= Connect.getInstance().getStmt("{call getIdCanton(?)}");
      stmt.setString(1,NameCanton);
      ResultSet myRs = stmt.executeQuery();
      while(myRs.next()){
            idCanton= myRs.getInt("id_canton");
        }
    }catch(SQLException ex){
        System.out.println(ex.getMessage());
    }
        return idCanton;
   }
    
    
     //Get del id de un distrito a partir del nombre
     public  int getIdDistrict(String NameDistrict){
    int idDistrict=-1;
    try{
      CallableStatement stmt= Connect.getInstance().getStmt("{call getIdDistrict(?)}");
      stmt.setString(1,NameDistrict);
      ResultSet myRs = stmt.executeQuery();
      while(myRs.next()){
            idDistrict= myRs.getInt("id_District");
        }
    }catch(SQLException ex){
        System.out.println(ex.getMessage());
    }
        return idDistrict;
   }
   //FIN GETS ID LOCALIZACIONES
     
    
     
     
   //INICIO INSERTS LOCALIZACIONES
     //Procedimiento que inserta un nuevo contienente
     public  void insertContinent(String ContinentName){
        try{
            CallableStatement stmt= Connect.getInstance().getStmt("{call insert_Continent(?)}");
            stmt.setString(1,ContinentName);
            stmt.execute();
        }catch(SQLException ex){
           showMessageDialog(null,"El continente ya se encuentra insertado,pruebe con otro. ");
        }    
     }
     
     //Procedimiento que inserta un nuevo pais
     public  void insertCountry(String CountryName,String ContinentName){
        try{
            CallableStatement stmt= Connect.getInstance().getStmt("{call insert_Country(?,?)}");
            stmt.setString(1,CountryName);
            
            stmt.setInt(2, getIdContinent(ContinentName));
            stmt.execute();
        }catch(SQLException ex){
           showMessageDialog(null,"El país ya se encuentra insertado,pruebe con otro.");
        }    
     }
     //Procedimiento que inserta una nueva provincia
      public  void insertProvince(String ProvinceName,String CountryName){
        try{
            CallableStatement stmt= Connect.getInstance().getStmt("{call insert_Province(?,?)}");
            stmt.setString(1,ProvinceName);
            stmt.setInt(2, getIdCountry(CountryName));
            stmt.execute();
        }catch(SQLException ex){
           showMessageDialog(null,"La provincia ya se encuentra insertada,pruebe con otra.");
        }    
     }
      //Procedimiento que inserta un nuevo canton
      public  void insertCanton (String CantonName,String ProvinceName){
          try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_Canton(?,?)}");
               stmt.setString(1, CantonName);
               stmt.setInt(2,getIdProvince(ProvinceName));
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El cantón ingresado ya se encuentra insertado.");
        }  
      }
     //Procedimiento que inserta un nuevo distrito
      
       public  void insertDistrict (String DistrictName,String CantonName){
          try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_District(?,?)}");
               stmt.setString(1, DistrictName);
               stmt.setInt(2,getIdCanton(CantonName));
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El distrito ya se encuentra insertado.");
        }  
      }
       //Procedimiento que inserta un nuevo estadio
       public void insertStadium(String stadiumName,String ProvinceName){
            try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_Stadium(?,?)}");
               stmt.setString(1, stadiumName);
               stmt.setInt(2,getIdProvince(ProvinceName));
               stmt.execute();
          }catch(SQLException ex){
             showMessageDialog(null,"El estadio ya se encuentra insertado,pruebe con otro.");
        }  
           
       }
   //FIN  INSERTS LOCALIZACIONES
       
       
        //INICIO UPDATES LOCALIZACIONES
       //
       
       //Procedimiento que actualiza un contienente a partir del nombre
       public  void updateContinent(String ContinentName, String newName){
           try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call updateContinent(?,?)}");
               stmt.setInt(1,getIdContinent(ContinentName));
               stmt.setString(2,newName);
               stmt.execute();
          }catch(SQLException ex){
             showMessageDialog(null,"El continente ya se encuentra insertado,pruebe con otro.");
        }  
       
       }
       //Procedimiento que actualiza un pais a partir del nombre
       public  void updateCountry(String CountryName,String newName, String ContinentName){
           try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call updateCountry(?,?,?)}");
               stmt.setInt(1,getIdCountry(CountryName));
               stmt.setString(2,newName);
               if(ContinentName==null){
                stmt.setString(3,ContinentName);
               }else{
                stmt.setString(3,String.valueOf(getIdContinent(ContinentName)));
               }
              
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El país ya se encuentra insertado,pruebe con otro.");
        }  
       }
       
       //Procedimiento que actualiza una provincia a partir del nombre
       public  void updateProvince(String ProvinceName,String newName, String CountryName){
           try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call updateProvince(?,?,?)}");
               stmt.setInt(1,getIdProvince(ProvinceName));
               stmt.setString(2,newName);
               if(CountryName==null){
                stmt.setString(3,CountryName);
               }else{
                stmt.setString(3,String.valueOf(getIdCountry(CountryName)));
               }
              
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"La provincia ya se encuentra insertada.");
        }
       }
       //Procedimiento que actualiza un canton a partir del nombre
       
       public  void updateCanton(String CantonName,String newName,String ProvinceName){
           try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call updateCanton(?,?,?)}");
               stmt.setInt(1,getIdCanton(CantonName));
               stmt.setString(2,newName);
               if(ProvinceName==null){
                stmt.setString(3,ProvinceName);
               }else{
                stmt.setString(3,String.valueOf(getIdProvince(ProvinceName)));
               }
              
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El cantón ya se encuentra insertado,pruebe con otro.");
        }
       }
       //Procedimiento que actualiza un distrito a partir del nombre
       public  void updateDistrict(String DistrictName,String newName,String CantonName){
           try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call updateDistrict(?,?,?)}");
               stmt.setInt(1,getIdDistrict(DistrictName));
               stmt.setString(2,newName);
               if(CantonName==null){
                stmt.setString(3,CantonName);
               }else{
                stmt.setString(3,String.valueOf(getIdCanton(CantonName)));
               }
              
               stmt.execute();
          }catch(SQLException ex){
             showMessageDialog(null,"El distrito ya se encuentra insertado,pruebe con otro.");
        }
       }
       
       
       //Get del estadio a partir del nombre
       public int getIdStadium(String nameStadium){
           int idStadium=-1;
    try{
      CallableStatement stmt= Connect.getInstance().getStmt("{call getIdStadium(?)}");
      stmt.setString(1,nameStadium);
      ResultSet myRs = stmt.executeQuery();
      while(myRs.next()){
            idStadium= myRs.getInt("id_Stadium");
        }
    }catch(SQLException ex){
        System.out.println(ex.getMessage());
    }
        return idStadium;
       }
       //Procedimiento que actualiza un estadio a partir del nombre
       
       public void updateStadium(String StadiumName,String newName,String ProvinceName){
           try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call updateStadium(?,?,?)}");
               stmt.setInt(1,getIdStadium(StadiumName));
               stmt.setString(2,newName);
               if(ProvinceName==null){
                stmt.setString(3,ProvinceName);
               }else{
                stmt.setString(3,String.valueOf(getIdProvince(ProvinceName)));
               }
              
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El estadio ya se encuentra insertado,pruebe con otro.");
        }
       }
       
       
   //FIN UPDATES LOCALIZACIONES
       
       
       
   //INICIO CONSULTAS PRINCIPALES CON SUS GETS 
       //get de el id del evento a partir de una fecha y tipo
    public  int getIdEvent(String Year,String eventType){
        int idEvent=-1;
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getEventID(?,?)}");
          stmt.setString(1,Year);
          stmt.setString(2,eventType);
          ResultSet myRs = stmt.executeQuery();
          while(myRs.next()){
                idEvent= myRs.getInt("id_event");
            }
        }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return idEvent;
   }
    
    //get del id del grupo a partir de la fecha del evento y el nombre del grupo
    
    public  int getIdGroup(String Year,String eventType,String groupName ){
        int idEvent=-1;
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getIdGroup(?,?)}");
          
          stmt.setString(1,groupName);
          stmt.setInt(2,getIdEvent(Year,eventType));
          ResultSet myRs = stmt.executeQuery();
          while(myRs.next()){
                idEvent= myRs.getInt("id_group");
            }
        }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return idEvent;
   }
    
    
                                //todas las consultas
    
    //COnsulta que regresa los resultados por evento y por grupo, recibe la fecha, el tipo de evento y el nombre del grupo
    public  ArrayList<ArrayList<String>> getResultbyEventAndGroup(String Year,String eventType,String groupName){
         ArrayList<ArrayList<String>>rowsResult= new ArrayList<ArrayList<String>>();
         try{
             int id_event=getIdEvent(Year,eventType);
             int id_group= getIdGroup(Year,eventType,groupName);
          CallableStatement stmt= Connect.getInstance().getStmt("{call getStatitisticForjava(?,?)}");
          stmt.setInt(1,id_event);
          if(groupName==null){
            stmt.setString(2,groupName);
          }else{
              stmt.setInt(2,id_group);
          }
          ResultSet myRs = stmt.executeQuery();
          while(myRs.next()){
            ArrayList<String> tempRow= new ArrayList<String>();
            tempRow.add(myRs.getString("logo_team"));
            tempRow.add(myRs.getString("team_name"));
            tempRow.add(myRs.getString("juegos"));
            tempRow.add(myRs.getString("total_victorias"));
            tempRow.add(myRs.getString("total_empates"));
            tempRow.add(myRs.getString("total_derrotas"));
            tempRow.add(myRs.getString("goles_totales"));
            tempRow.add(myRs.getString("goles_contra_totales"));
            tempRow.add(myRs.getString("gol_diferencia_totales"));
            tempRow.add(myRs.getString("puntos_Fairy_play__totales"));
            tempRow.add(myRs.getString("Puntos_totales"));
            rowsResult.add(tempRow);
            }
        }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
         
         return rowsResult;
     }
     
    //Consulta que regresa las estadisitricas de un evento, reciben, fecha y tipo de evento.
    public  ArrayList<String> getStatisticbyEvent(String Year,String eventType){
        ArrayList<String>rowsResult= new ArrayList<String>();
        double tempNumber;
        try{
          int id_event=getIdEvent(Year,eventType);
          CallableStatement stmt= Connect.getInstance().getStmt("{call getStatisticbyEvent(?)}");
          stmt.setInt(1,id_event);
          ResultSet myRs = stmt.executeQuery();
          while(myRs.next()){
              
              rowsResult.add(myRs.getString("PorcentajeGoles"));
              rowsResult.add(myRs.getString("PorcentajeAmarillas"));
              rowsResult.add(myRs.getString("PorcentajeRojas"));
              rowsResult.add(myRs.getString("Promediotiros"));
              rowsResult.add(myRs.getString("TotalPartidos"));
              
          }  
        }catch(SQLException ex){
            showMessageDialog(null,"No hay partidos en el evento seleccionado");
        }
         return  rowsResult;
    }    
    
    //Consulta que regresa una matriz con las jugadas por eventos y fecha, recibe fecha, tipo de evento y fecha del partido
    public  ArrayList<ArrayList<String>>  getPlaysByEventAndDate(String Year,String eventType, String Date){
        ArrayList<ArrayList<String>>rowsResult= new ArrayList<ArrayList<String>>();
         try{
          int id_event=getIdEvent(Year,eventType);
          CallableStatement stmt= Connect.getInstance().getStmt("{call getPlaysByEventAndDate(?,?)}");
          stmt.setInt(1,id_event);
        
          stmt.setString(2,Date);

          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
              ArrayList<String> tempRow= new ArrayList<String>();
            tempRow.add(myRs.getString("team_name"));
            tempRow.add(myRs.getString("player_name"));
            tempRow.add(myRs.getString("play_name"));
            tempRow.add(myRs.getString("minute"));
            
            
            rowsResult.add(tempRow);
            }
        
       }catch(SQLException ex){
            showMessageDialog(null,"No hay jugadas en este evento");
        }
         return rowsResult;
    }
    
    //Consulta que regresa el estadio de un partido de un evento.
    public  String  getStadiumbyEventAndDate(String Year,String eventType , String Date){
        String Stadium="";
         try{
          int id_event=getIdEvent(Year,eventType);
          CallableStatement stmt= Connect.getInstance().getStmt("{call getStadiumbyEventAndDate(?,?)}");
          stmt.setInt(1,id_event);
          stmt.setString(2,Date);
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
           
           Stadium= myRs.getString("stadium_name");
            
         
           }
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
         return Stadium;
    }
     
             //Consulta que regresa una matriz con las sanciones por evento y fecha, recibe fecha, tipo de evento y fecha de partido
      public  ArrayList<ArrayList<String>>  getSanctionsbyEventAndDate(String Year,String eventType , String Date){
        ArrayList<ArrayList<String>>rowsResult= new ArrayList<ArrayList<String>>();
         try{
          int id_event=getIdEvent(Year,eventType);
          CallableStatement stmt= Connect.getInstance().getStmt("{call getSanctionsbyEventAndDate(?,?)}");
          stmt.setInt(1,id_event);
          stmt.setString(2,Date);
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
            ArrayList<String> tempRow= new ArrayList<String>();
            tempRow.add(myRs.getString("team_name"));
            tempRow.add(myRs.getString("player_name"));
            tempRow.add(myRs.getString("sanction_name"));
            tempRow.add(myRs.getString("minute"));
            rowsResult.add(tempRow);
           }
       }catch(SQLException ex){
            showMessageDialog(null,"No hay sanciones en este evento");
        }
         return rowsResult;
    }       
     
    //FIN CONSULTAS PRINCIPALES   
    //CONSULTAS EXTRA //
      //Consulta que regrea un top N de jugadores, dependiendo de los goles que realizo en el evento
        public  ArrayList<ArrayList<String>> getTopNPlayerExtra(String Year,String eventType,int Ntop){
       ArrayList<ArrayList<String>> TopNPlayer = new ArrayList<ArrayList<String>>();
        try{
          int id_event=getIdEvent(Year,eventType);
          CallableStatement stmt= Connect.getInstance().getStmt("{call getTopNPlayer(?,?)}");
          stmt.setInt(1,id_event);
          stmt.setInt(2,Ntop);

          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               ArrayList<String> tempRow= new ArrayList<String>();
               
               tempRow.add(myRs.getString("player_name"));
               tempRow.add(myRs.getString("team_name"));
               tempRow.add(myRs.getString("goles"));
               TopNPlayer.add(tempRow);
           }
        
       }catch(SQLException ex){
           showMessageDialog(null,"No hay jugadores con goles en este evento");
        }
        return TopNPlayer;
        
    }
    // Consulta que regresa una matriz con los peores jugadores, depende del los puntos de fair play, recibe la fecha, tipo de evento y el nummero
        //de jugadores que se quiera desplega
     public  ArrayList<ArrayList<String>> getTopNWorstPlayer(String Year,String eventType,int Ntop){
        ArrayList<ArrayList<String>> TopNPlayer = new ArrayList<ArrayList<String>>();
        try{
          int id_event=getIdEvent(Year,eventType);
          CallableStatement stmt= Connect.getInstance().getStmt("{call getTopNWorstPlayer(?,?)}");
          stmt.setInt(1,id_event);
          stmt.setInt(2,Ntop);
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               ArrayList<String> tempRow= new ArrayList<String>();
               
               tempRow.add(myRs.getString("player_name"));
               tempRow.add(myRs.getString("team_name"));
               tempRow.add(myRs.getString("sanciones"));
               TopNPlayer.add(tempRow);
           }
        
       }catch(SQLException ex){
            showMessageDialog(null,"No hay jugadores con sanciones en este evento");
        }
        return TopNPlayer;
        
    }    
        
      //FIN CONSULTAS EXTRA
 
    //INICIO CONSULTAS EVENTOS Y GRUPOS
     //COnsulta que regresa los grupos que existen en un evento
    public  ArrayList<String> getGroupsByEvent(String Year,String eventType){
        ArrayList<String> groups = new ArrayList<String>();
        try{
          int id_event=getIdEvent(Year,eventType);
          CallableStatement stmt= Connect.getInstance().getStmt("{call getGroupsByEvent(?)}");
          stmt.setInt(1,id_event);
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               groups.add(myRs.getString("group_name"));
               
           }
        
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return groups;
        
    }
                        //gets del evento
    
    
    //Consulta que regresa las fechas dependiendo del tipo de eventos, recibe el tipo de evento
    public  ArrayList<String> getYearByTypeEvent(String nameTypeEvent){
        ArrayList<String> events = new ArrayList<String>();
        try{
         
          CallableStatement stmt= Connect.getInstance().getStmt("{call getYearByTypeEvent(?)}");
          stmt.setInt(1,getIdTypeEvent(nameTypeEvent));
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               events.add(myRs.getString("date"));
           }
        
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return events;
        
    }
    //Consulta que regrsa los equipos que jugaron por un evento
    public ArrayList<String> getdateTeamSbyEvent(String Date,String TypeEvent){
        ArrayList<String> years = new ArrayList<String>();
        try{
         
          CallableStatement stmt= Connect.getInstance().getStmt("{call getdateTeamSbyEvent(?)}");
          stmt.setInt(1,getIdEvent(Date,TypeEvent));
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               years.add(myRs.getString("date"));
           }
        
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return years;
    }
    
    //FIN CONSULTAS EVENTOS Y GRUPOS
    
    
    //INICIO INSERTAR TEAM Y PERSONAS
    
    //Get que regresa el id de un equipo a partir del nombre
     public  int getIdTeam(String teamName){
          int idAlignment= -1;
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getIdTeam(?)}");
        stmt.setString(1, teamName);
        ResultSet myRs = stmt.executeQuery();     
        while(myRs.next()){
        idAlignment= myRs.getInt("id_team");
        }
      }catch(SQLException ex){
        System.out.println(ex.getMessage());
      }                              
       return idAlignment;
     }
    
    //Procedimiento que crea un nuevo equipo, recibe el nombre del pais, la alineacion por defecto
     //el capitam, nombre y logo
    public  void createTeam(String countryName,String aligmentName,String idCaptain, String teamName,String Logo){
       try{
         CallableStatement stmt= Connect.getInstance().getStmt("{call insert_team(?,?,?,?,?)}");
         stmt.setInt(1,getIdCountry(countryName));
         stmt.setInt(2, getIdAlignment(aligmentName));
         stmt.setString(3, idCaptain);
         stmt.setString(4, teamName);
         stmt.setString(5, Logo);
         
          stmt.execute();
      }catch(SQLException ex){
      showMessageDialog(null,"El equipo ya se encuentra insertado, o hay un error en los datos.");
      }
    }
    //Procedimiento que actualiza la informacion de una equipo, si envia null no realiza cambios.
    public  void updateTeam(String teamName,String newName,String CountryName,String alignmentName,String captainName,String Logo){
        try{
         CallableStatement stmt= Connect.getInstance().getStmt("{call updateTeam(?,?,?,?,?,?)}");
         stmt.setInt(1,getIdTeam(teamName));
         stmt.setString(2, newName);
         if(CountryName==null){
            stmt.setString(3,CountryName);
         }else{
            stmt.setInt(3, getIdCountry(CountryName));
         }
         if(alignmentName==null){
            stmt.setString(4, alignmentName);
         }else{
            stmt.setInt(4,getIdAlignment(alignmentName));
         }
          if(captainName==null){
            stmt.setString(5, captainName);
         }else{
            stmt.setInt(5,getIdPlayer(captainName));
         }
          stmt.setString(6, Logo);
          stmt.execute();
      }catch(SQLException ex){
      showMessageDialog(null,"El equipo ya se encuentra insertado, o hay un error en los datos.");
      }
    }
    
    //Get que retorna el id del jugador a partir del nom re
    public  int getIdPlayer(String playerName){
          int idplayer= -1;
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getIdPlayer(?)}");
        stmt.setString(1, playerName);
        ResultSet myRs = stmt.executeQuery();     
        while(myRs.next()){
        idplayer= myRs.getInt("id_player");
        }
      }catch(SQLException ex){
        System.out.println(ex.getMessage());
      }                              
       return idplayer;
     }
    
    
    //Procedimiento que crea un nuevo jugador
    public  void insertPlayer(String PlayerName,int number,int identificacition,String picture,String teamName,String nationality){
        try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_player(?,?,?,?,?,?)}");
               stmt.setString(1, PlayerName);
               stmt.setInt(2,number);
               stmt.setInt(3,identificacition);
               stmt.setString(4, picture);
               stmt.setInt(5, getIdTeam(teamName));
               stmt.setInt(6, getIdNationality(nationality));
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El jugador ya se encuentra insertado, o hay un error en los datos.");
        }  
    }
    
    
    //Procedimiento que actualiza la informacion de un juegador
    
    public  void updatePlayer(String PlayerName,String newName,String newNumber,String newIdentificacition,String newPicture,String newTeamName,String newNationality){
        try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call updatePlayer(?,?,?,?,?,?,?)}");
               stmt.setInt(1, getIdPlayer(PlayerName));
               stmt.setString(2,newName);
               stmt.setString(3,newNumber);
               stmt.setString(4, newIdentificacition);
               stmt.setString(5, newPicture);
               if(newTeamName==null){
                    stmt.setString(6, newTeamName);
               }else{
                    stmt.setInt(6, getIdTeam(newTeamName));
               }
               if(newNationality==null){
                   stmt.setString(7, newNationality);
               }else{
                   stmt.setInt(7,getIdNationality(newNationality));
               }
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El jugador ya se encuentra insertado, o hay un error en los datos.");
        }        
    }
    //Consulta que regresa los nombres de los jugadores en un equipo, recibe el nombre del equipo
    public   ArrayList<String> getPlayerNamesbyTeam(String TeamName){
        ArrayList<String> players = new ArrayList<String>();
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getPlayerNamesbyTeam(?)}");
          stmt.setString(1,TeamName);
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               players.add(myRs.getString("player_name"));
           }
        
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return players;
    }
    
    //Consulta que regresa todos los nombres de los equipos existentes.
    public  ArrayList<String> getTeamNames(){
        ArrayList<String> teams = new ArrayList<String>();
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getTeamNames()}");
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               teams.add(myRs.getString("team_name"));
           }
        
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return teams;
    }
    //FIN INSERTAR TEAM Y PERSONAS
    
    
    
    
    // INICIO EVENTOS INSERT EVENT Y GROUP, GET LISTA tYPOS EVENTOS Y GETIDTIPOEVENTO
    //CREAR EVENTO Y GRUPO
    //Consulta que regresa una lista con los nombres de los tipos de eventos existentes
    public  ArrayList<String> getTypeEvents(){
        ArrayList<String> players = new ArrayList<String>();
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getTypeEvents()}");
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               players.add(myRs.getString("name_type_event"));
           }
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return players;
    }
    
    //Procedimiento que regresa el id del tipo de evento a partir del nombre
    public  int getIdTypeEvent(String typeEventName){
          int idplayer= -1;
       try{
        CallableStatement stmt= Connect.getInstance().getStmt("{call getIdTypeEvent(?)}");
        stmt.setString(1, typeEventName);
        ResultSet myRs = stmt.executeQuery();     
        while(myRs.next()){
        idplayer= myRs.getInt("id_type_event");
        }
      }catch(SQLException ex){
        System.out.println(ex.getMessage());
      }                              
       return idplayer;
     }
    
    //Procedimiento que crea un nuevo tipo de evento, recibe un nombre.
    public  void createtypeEvent(String typeEvent){
        try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_typevent(?)}");
               stmt.setString(1, typeEvent);
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El tipo de evento ya se encuentra insertado");
        }
    }
    //Procedimiento que actualiza un tipo de evento, recibe el nombre
    public  void updateTypeEvent(String typeEvent,String newName){
        try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call updatetypeEvent(?,?)}");
               stmt.setInt(1,getIdTypeEvent( typeEvent));
               stmt.setString(2,newName);
        
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El tipo de evento ya se encuentra insertado");
        }  
    }
    //Procedimiento que crea un nuevo evento, recibe una fecha y ell tipo de evento
    public  void createEvent(String Date,String TypeeventName){
        try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_event(?,?)}");
               stmt.setString(1, Date);
               stmt.setInt(2,getIdTypeEvent(TypeeventName));
        
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El evento ya se encuentra insertado o hay un error en los datos");
        }  
    }
    //Procedimiento que actualiza la informacion de un evento.
    public void updateEvent(String year,String TypeeventName,String newDate,String newTypeEvent){
        try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call updateEvent(?,?,?)}");
               stmt.setInt(1,getIdEvent(year,TypeeventName ));
               stmt.setString(2,newDate);
               if(newTypeEvent==null){
                stmt.setString(3,newTypeEvent);
               }else{              
                stmt.setInt(3, getIdTypeEvent(newTypeEvent));
               }
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,ex.getMessage());
        }  
    }
    //Procedimiento que crea un nuevo grupo, recibe el nombre y la fecha del evento.
    public  void createGroup(String groupName,String year,String typeEvent){
        try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_group(?,?)}");
               stmt.setString(1, groupName);
               
               stmt.setInt(2,getIdEvent(year,typeEvent));
        
               stmt.execute();
          }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }  
    }
    
    
     // FIN EVENTOS INSERT EVENT Y GROUP, GET LISTA tYPOS EVENTOS Y GETIDTIPOEVENTO CREAR EVENTO Y GRUPO
    
    //CREAR PARTIDO,SANCIONES  Y JUGADAS
    //get que a partir de una fecha retorna el id del partido
    public int getIdMatch(String DateMatch){
        int IDMatch=-1;
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getIDMatch(?)}");
          stmt.setString(1,DateMatch);
          ResultSet myRs = stmt.executeQuery();
          while(myRs.next()){
                IDMatch= myRs.getInt("id_match");
            }
        }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
            return IDMatch;
        
    }
    
    
    //Procedimiento que crea un nuevo partido recibe, la fecha del evento, el tipo de evento, el nombre del estadio, la fecha del partido
    public void createMatch(String dateEvent,String typeEvent,String stadiumName,String date){
         try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_match(?,?,?)}");
               stmt.setInt(1,getIdEvent(dateEvent,typeEvent) );
               stmt.setInt(2,getIdStadium(stadiumName));
               stmt.setString(3, date);    
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El partido ya se encuentra insertado o hay un error en los datos");
        }  
    }
    
    //Crea un nuevo partido por equipo, recibe la fecha y el nombre del equipo
    public void createMatchXTeam(String DateMatch, String TeamName){
         try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_team_x_match(?,?)}");
               stmt.setInt(1,getIdTeam(TeamName) );
               stmt.setInt(2,getIdMatch(DateMatch));
                 
               stmt.execute();
          }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }  
    }
    //Procedimiento que crea un nuevo tipo de sancion, recibe el nombre
    public void createSanctionType(String sanctionTypeName){
         try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_sanctiontype(?)}");
               stmt.setString(1,sanctionTypeName);

               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El tipo de sanción ya se encuentra insertada");
        }  
    }
    //Procedimiento que ingresa un nuevo tipo de jugada al catologo tipo de jugada
     public void createPlayType(String playTypeName){
         try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_typeplay(?)}");
               stmt.setString(1,playTypeName);

               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"El tipo de jugada ya se encuentra insertada");
        }  
    }
     
     public void updatePlayType(String namePlayType, String  newName){
          try{
            CallableStatement stmt= Connect.getInstance().getStmt("{call updateTypePlay(?,?)}");
            stmt.setInt(1, getIdPlayType(namePlayType));
            stmt.setString(2, newName);
            stmt.execute();
        }catch(SQLException ex){     
      showMessageDialog(null,"El tipo de jugada ya se encuentra registrada");
     }
     }
     
     public void updateSanctionType(String nameSanctionType, String  newName){
          try{
            CallableStatement stmt= Connect.getInstance().getStmt("{call updateSanctionType(?,?)}");
            stmt.setInt(1, getIdSanctionType(nameSanctionType));
            stmt.setString(2, newName);
            stmt.execute();
        }catch(SQLException ex){     
      showMessageDialog(null,"El tipo de sanción ya se encuentra registrada");
     }
     }
     
     //Procedimiento que regresa el id del tipo de sancion a partir del nombre
     public int getIdSanctionType(String typeName){
        int idsanction=-1;
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getIdSanctionType(?)}");
          stmt.setString(1,typeName);
          ResultSet myRs = stmt.executeQuery();
          while(myRs.next()){
                idsanction= myRs.getInt("id_sanction_type");
            }
        }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
            return idsanction;
     }
            
        //Procedimiento que regresa el id del tipo de jugada a parit del nombre
        public int getIdPlayType(String typeName){
            int idplay=-1;
            try{
              CallableStatement stmt= Connect.getInstance().getStmt("{call getIdPlayType(?)}");
              stmt.setString(1,typeName);
              ResultSet myRs = stmt.executeQuery();
              while(myRs.next()){
                    idplay= myRs.getInt("id_type_play");
                }
            }catch(SQLException ex){
                System.out.println(ex.getMessage());
            }
                return idplay;        
        }
        
    //Procedimiento que regresa la lista de los tipos de sanciones    
    public ArrayList<String> getTypeSanction(){   
            ArrayList<String> typeSanction = new ArrayList<String>();
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getTypeSanction()}");
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               typeSanction.add(myRs.getString("sanction_name"));
           }
        
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return typeSanction;
    }
        
    
    //Procedimiento que regresa la lista de tipo de juegos
    public ArrayList<String> getTypePlay(){   
            ArrayList<String> typelay = new ArrayList<String>();
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getTypePlay()}");
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               typelay.add(myRs.getString("play_name"));
           }
        
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return typelay;
    }
    
    //Procedimiento que crea una sancion, ingresa un tipo de sancion, el nombre, minuto y la fecha del partido
    public void createSanction(String sanctionTypeName,String playerName,String minute,String MatchDate){
         try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_sanction(?,?,?,?)}");
               stmt.setInt(1,getIdSanctionType(sanctionTypeName));
               stmt.setInt(2, getIdPlayer(playerName));
               stmt.setString(3, minute);
               stmt.setInt(4,getIdMatch(MatchDate) );
               stmt.execute();
          }catch(SQLException ex){
            showMessageDialog(null,"Hay un error en los datos");
        }  
    }
    //Procedimiento que crea una jugada en un partido, recibe el minuto, la fecha del partido, el nombre del jugador que hizo la jugada y el tipo de  jugada
    public void createPlay(String minute,String MatchDate,String playerName,String playTypeName){
         try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insert_play(?,?,?,?)}");
               stmt.setString(1,minute);
               stmt.setInt(2,getIdMatch(MatchDate));
               stmt.setInt(3,getIdPlayer(playerName) );
               stmt.setInt(4,getIdPlayType(playTypeName));
               stmt.execute();
          }catch(SQLException ex){
             showMessageDialog(null,"Hay un error en los datos");
        }  
    }
  
    //Procedimiento que crea grupos rando para un evento, recibe el numeor de equipos, el nombre del grupo la fecha del evento, el tipo
    void insertRandomteamsInGroup(int cantTeams,String groupName,String eventDate,String TypeEvent){
        try{
               CallableStatement stmt= Connect.getInstance().getStmt("{call insertRandom(?,?,?,?)}");
               stmt.setInt(1,cantTeams);
               stmt.setInt(2,getIdGroup(eventDate,TypeEvent,groupName));
               stmt.setInt(3,getIdEvent(eventDate,TypeEvent));
               
               stmt.execute();
          }catch(SQLException ex){
             showMessageDialog(null,"Hay un error en los datos");
        }  
    }
    // FIN CREAR PARTIDO,SANCIONES  Y JUGADAS
    
    
    //GET LOGO Y NOMBRE EQUIPOS POR PARTIDO
    //Procedimiento que regresa los nombre y los logos de dos equipo que se van a enfrentar.
    public ArrayList<ArrayList<String>> getLogoAndName(String Year,String eventType , String Date){
        ArrayList<ArrayList<String>> result = new ArrayList<>();
          try{
            CallableStatement stmt= Connect.getInstance().getStmt("{call getLogoAndName(?,?)}");
            stmt.setInt(1, getIdEvent(Year,eventType));
            stmt.setString(2,Date);
            ResultSet myRs = stmt.executeQuery();
             while(myRs.next()){
                 ArrayList<String> row = new ArrayList<>();
             row.add(myRs.getString("logo_team"));  
             row.add(myRs.getString("team_name"));
              result.add(row);
           }
           }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
          return result;
                
    }
    
    public ArrayList<String> getTeamsbygroup(String groupName,String dateEvent, String TypeeEvent){       
      ArrayList<String> teams = new ArrayList<String>();
        try{
          CallableStatement stmt= Connect.getInstance().getStmt("{call getTeamsbygroup(?,?)}");
          stmt.setString(1,groupName);
          stmt.setInt(2, getIdEvent(dateEvent,TypeeEvent));
          ResultSet myRs = stmt.executeQuery();
           while(myRs.next()){
               teams.add(myRs.getString("team_name"));
           }
       }catch(SQLException ex){
            System.out.println(ex.getMessage());
        }
        return teams;
    }
    
    private void updategroup_x_team(String Year,String eventType,String groupName,String teamName){
        try{
            CallableStatement stmt= Connect.getInstance().getStmt("{call updategroup_x_team(?,?)}");
            stmt.setInt(1,getIdGroup(Year,eventType,groupName));
            stmt.setInt(2, getIdTeam(teamName));
            stmt.execute();
        }catch(SQLException ex){
            
      showMessageDialog(null,"el equipo ya se encuentra en el grupo ya se encuentra registrada");
      }               
    }
    
 
        
    
            
}
